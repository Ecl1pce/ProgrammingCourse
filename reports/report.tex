\documentclass[12pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[OT1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{cmap} % поиск в PDF
\usepackage{mathtext} % русские буквы в формулах
%\usepackage{tikz-uml} % uml диаграммы

% TODOs
\usepackage[%
 colorinlistoftodos,
 shadow
]{todonotes}

% Генератор текста
\usepackage{blindtext}

%------------------------------------------------------------------------------

% Подсветка синтаксиса
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}

 % Цвета для кода
\definecolor{string}{HTML}{B40000} % цвет строк в коде
\definecolor{comment}{HTML}{008000} % цвет комментариев в коде
\definecolor{keyword}{HTML}{1A00FF} % цвет ключевых слов в коде
\definecolor{morecomment}{HTML}{8000FF} % цвет include и других элементов в коде
\definecolor{captiontext}{HTML}{FFFFFF} % цвет текста заголовка в коде
\definecolor{captionbk}{HTML}{999999} % цвет фона заголовка в коде
\definecolor{bk}{HTML}{FFFFFF} % цвет фона в коде
\definecolor{frame}{HTML}{999999} % цвет рамки в коде
\definecolor{brackets}{HTML}{B40000} % цвет скобок в коде

 % Настройки отображения кода
\lstset{
language=C, % Язык кода по умолчанию
morekeywords={*,...}, % если хотите добавить ключевые слова, то добавляйте
 % Цвета
keywordstyle=\color{keyword}\ttfamily\bfseries,
stringstyle=\color{string}\ttfamily,
commentstyle=\color{comment}\ttfamily\itshape,
morecomment=[l][\color{morecomment}]{\#},
 % Настройки отображения
breaklines=true, % Перенос длинных строк
basicstyle=\ttfamily\footnotesize, % Шрифт для отображения кода
backgroundcolor=\color{bk}, % Цвет фона кода
%frame=lrb,xleftmargin=\fboxsep,xrightmargin=-\fboxsep, % Рамка, подогнанная к заголовку
frame=tblr
rulecolor=\color{frame}, % Цвет рамки
tabsize=3, % Размер табуляции в пробелах
showstringspaces=false,
 % Настройка отображения номеров строк. Если не нужно, то удалите весь блок
numbers=left, % Слева отображаются номера строк
stepnumber=1, % Каждую строку нумеровать
numbersep=5pt, % Отступ от кода
numberstyle=\small\color{black}, % Стиль написания номеров строк
 % Для отображения русского языка
extendedchars=true,
literate={Ö}{{\"O}}1
 {Ä}{{\"A}}1
 {Ü}{{\"U}}1
 {ß}{{\ss}}1
 {ü}{{\"u}}1
 {ä}{{\"a}}1
 {ö}{{\"o}}1
 {~}{{\textasciitilde}}1
 {а}{{\selectfont\char224}}1
 {б}{{\selectfont\char225}}1
 {в}{{\selectfont\char226}}1
 {г}{{\selectfont\char227}}1
 {д}{{\selectfont\char228}}1
 {е}{{\selectfont\char229}}1
 {ё}{{\"e}}1
 {ж}{{\selectfont\char230}}1
 {з}{{\selectfont\char231}}1
 {и}{{\selectfont\char232}}1
 {й}{{\selectfont\char233}}1
 {к}{{\selectfont\char234}}1
 {л}{{\selectfont\char235}}1
 {м}{{\selectfont\char236}}1
 {н}{{\selectfont\char237}}1
 {о}{{\selectfont\char238}}1
 {п}{{\selectfont\char239}}1
 {р}{{\selectfont\char240}}1
 {с}{{\selectfont\char241}}1
 {т}{{\selectfont\char242}}1
 {у}{{\selectfont\char243}}1
 {ф}{{\selectfont\char244}}1
 {х}{{\selectfont\char245}}1
 {ц}{{\selectfont\char246}}1
 {ч}{{\selectfont\char247}}1
 {ш}{{\selectfont\char248}}1
 {щ}{{\selectfont\char249}}1
 {ъ}{{\selectfont\char250}}1
 {ы}{{\selectfont\char251}}1
 {ь}{{\selectfont\char252}}1
 {э}{{\selectfont\char253}}1
 {ю}{{\selectfont\char254}}1
 {я}{{\selectfont\char255}}1
 {А}{{\selectfont\char192}}1
 {Б}{{\selectfont\char193}}1
 {В}{{\selectfont\char194}}1
 {Г}{{\selectfont\char195}}1
 {Д}{{\selectfont\char196}}1
 {Е}{{\selectfont\char197}}1
 {Ё}{{\"E}}1
 {Ж}{{\selectfont\char198}}1
 {З}{{\selectfont\char199}}1
 {И}{{\selectfont\char200}}1
 {Й}{{\selectfont\char201}}1
 {К}{{\selectfont\char202}}1
 {Л}{{\selectfont\char203}}1
 {М}{{\selectfont\char204}}1
 {Н}{{\selectfont\char205}}1
 {О}{{\selectfont\char206}}1
 {П}{{\selectfont\char207}}1
 {Р}{{\selectfont\char208}}1
 {С}{{\selectfont\char209}}1
 {Т}{{\selectfont\char210}}1
 {У}{{\selectfont\char211}}1
 {Ф}{{\selectfont\char212}}1
 {Х}{{\selectfont\char213}}1
 {Ц}{{\selectfont\char214}}1
 {Ч}{{\selectfont\char215}}1
 {Ш}{{\selectfont\char216}}1
 {Щ}{{\selectfont\char217}}1
 {Ъ}{{\selectfont\char218}}1
 {Ы}{{\selectfont\char219}}1
 {Ь}{{\selectfont\char220}}1
 {Э}{{\selectfont\char221}}1
 {Ю}{{\selectfont\char222}}1
 {Я}{{\selectfont\char223}}1
 {і}{{\selectfont\char105}}1
 {ї}{{\selectfont\char168}}1
 {є}{{\selectfont\char185}}1
 {ґ}{{\selectfont\char160}}1
 {І}{{\selectfont\char73}}1
 {Ї}{{\selectfont\char136}}1
 {Є}{{\selectfont\char153}}1
 {Ґ}{{\selectfont\char128}}1
 {\{}{{{\color{brackets}\{}}}1 % Цвет скобок {
 {\}}{{{\color{brackets}\}}}}1 % Цвет скобок }
}


%------------------------------------------------------------------------------

\author{А.~Ю.~Осипов}
\title{Программирование}
\begin{document}
\maketitle
\tableofcontents{}
\chapter{Основные конструкции языка}
%############################################################
\section{Задание 1}
\subsection{Задание}
Пользователь задает номер сегодняшнего дня недели (от 1 до 7, например, 6).

Вывести номер дня недели завтрашнего и вчерашнего дня (например, завтра 7, вчера 5).
\subsection{Теоретические сведения}

%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
Было использованно:
\begin{enumerate}
\item[•] несколько функций для ввода и вывода информации, прототипы которых находятся в <stdio.h>
\item[•] конструкции "if" для решения поставленной задачи
\end{enumerate}

%Сведения о предметной области, которые позволили реализовать алгоритм решения задачи.
Для решения поставленной задачи оказалось достаточно знание синтаксиса ввода-вывода языка си и элементарных математических операций.


\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с %пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.

Было решено сделать реализацию программы в одной функции в файле \verb-daynumbers.cpp- :
\begin{enumerate}
\item[•]  \verb-daynumbers- для вычисления номера предыдущего и следующего дня недели (и вывода результата работы в консоль)

\end{enumerate}


\subsection{Описание тестового стенда и методики тестирования}
%Среда, компилятор, операционная система, др.
Использовался Qt Creator 3.5.0 (opensource) с GCC 4.9.1 компилятором
Операционная система: Windows 7


%Ручное тестирование, автоматическое, статический анализ кода, динамический.
Ручное тестирование присутствовало в минимальном объеме.
Для статического анализа был использован cppcheckgui версии 1.7.1 . Ошибок и предупреждений не было.
Автоматическое тестирование с применением модульных тестов не проводилось.


\subsection{Выводы}

При написании данной программы, возникли проблемы с вынесением функций в отдельные файлы и использованием заголовочных файлов, но они были решены в ходе работы.

\subsection{Листинги}
\lstinputlisting[]
{../sources/app/daynumbers.h}
\lstinputlisting[]
{../sources/app/daynumbers.c}


%############################################################

\section{Задание 2}
\subsection{Задание}
Задано произвольное натуральное число, например, $5433$. Определить, делится ли число нацело на три.
\subsection{Теоретические сведения}

%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
Было использованно:
\begin{enumerate}
\item[•] конструкция "if" для создания нескольких исходов выполнения программы
\item[•] несколько функций для ввода и вывода информации, прототипы которых находятся в <stdio.h>
\item[•] функция получения остатка от деления " % "
\end{enumerate}

%Сведения о предметной области, которые позволили реализовать алгоритм решения задачи.
Для решения поставленной задачи оказалось достаточно знание синтаксиса ввода-вывода и базовых математических операций языка С.

\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с %пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.

Было решено сделать реализацию поставленной задачи в одной функции, находящейся в файле  \verb-DivideBy3.cpp-:
\begin{enumerate}
\item[•]  \verb-DivideBy3- (функция определяет, делится ли число нацело на 3 и выводит соответствующий результат в консоль)
\end{enumerate}

В данном приложении бизнес-логика не отделялась от взаимодействия с пользователем.

\subsection{Описание тестового стенда и методики тестирования}

%Среда, компилятор, операционная система, др.
Использовался Qt Creator 3.5.0 (opensource) с GCC 4.9.1 компилятором
Операционная система: Windows 7


%Ручное тестирование, автоматическое, статический анализ кода, динамический.
Ручное тестирование проводилось.
Для статического анализа был использован cppcheckgui версии 1.7.1 . Ошибок и предупреждений не было.
Автоматическое тестирование с использованием модульных тестов отсутствовало.


\subsection{Выводы}

При написании данной программы проблем не возникло из-за ее простоты и малых размеров.

\subsection{Листинги}
\lstinputlisting[]
{../sources/app/divideby3.h}
\lstinputlisting[]
{../sources/app/divideby3.c}




%############################################################
\chapter{Циклы}
\section{Задание 1}
\subsection{Задание}

Найти N-ю цифру последовательности 11235813213455..., составленной из чисел Фибоначчи. Например, 9-я цифра равна 2. Строковые функции не использовать.

\subsection{Теоретические сведения}

%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
Было использовано:
\begin{enumerate}
\item[•] цикл for для образования последовательности Фибоначчи
\item[•] целочисленный массив для хранения чисел Фибоначчи
\item[•] несколько функций для ввода и вывода информации, прототипы которых находятся в <stdio.h>
\item[•] функция возведения числа в степень, прототип которой находятся в <math.h>
\end{enumerate}

%Сведения о предметной области, которые позволили реализовать алгоритм решения задачи.
Для решения поставленной задачи оказалось достаточно знание основ синтаксиса языка С и наличие абстрактного мышления.

Было решено попутно вместе с образованием последовательности Фибоначчи запоминать ее длину, и, когда эта длина станет больше или равна номеру нужного нам элемента, выделять из последовательности целое число и уже внутри него искать нужную цифру функцией \verb-check-

\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с %пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.

Было решено выделить одну функцию для взаимодействия с пользователем, находящуюся в файле \verb-fibonacci.cpp-:
\begin{enumerate}
\item[•] \verb-fibonacci- для ввода данных из консоли, построения последовательности Фибоначчи и выделения из нее N-ной цифры
\end{enumerate}


Для бизнес логики было решено выделить одну функцию,находящуюся в файле \verb-check-:
\begin{enumerate}
\item[•] \verb-check_number_of_number- функция для нахождения длины числа
\end{enumerate}


\subsection{Описание тестового стенда и методики тестирования}

%Среда, компилятор, операционная система, др.
Использовался Qt Creator 3.5.0 (opensource) с GCC 4.9.1 компилятором
Операционная система: Windows 7


%Ручное тестирование, автоматическое, статический анализ кода, динамический.
Ручное тестирование проводилось в небольшом объеме.
Для статического анализа был использован cppcheckgui версии 1.7.1 . Ошибок и предупреждений не было.
Автоматическое тестирование не проводилось.


\subsection{Выводы}

При написании программы изначально было неясно как выделить именно цифру (а не число) из последовательности. Однако, через некоторое время решение было обнаружено: необходимо работать с длинами чисел вместо того,чтобы работать с самими числами.

\subsection{Листинги}
\lstinputlisting[]
{../sources/app/fibonacci.h}
\lstinputlisting[]
{../sources/app/fibonacci.c}
\lstinputlisting[]
{../sources/app/check.h}
\lstinputlisting[]
{../sources/app/check.c}



\chapter{Массивы}

\section{Задание 1}

\subsection{Задание}

 В матрице A(m,n) записаны натуральные числа. Найти первую строку, в которой либо все числа – простые, либо все числа – составные. Вывести строку и обнаруженный признак (составные числа/простые числа).

\subsection{Теоретические сведения}

%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
Было использовано:
\begin{enumerate}
\item[•] функции стандартной библиотеки для динамического выделения памяти из <stdlib.h>
\item[•] несколько функций для ввода и вывода информации, прототипы которых находятся в <stdio.h>
\item[•] функции работы с памятью, прототипы которых находятся в <stdlib.h>
\end{enumerate}

%Сведения о предметной области, которые позволили реализовать алгоритм решения задачи.
Потребовалось знания синтаксиса языка С и некоторое представление о двумерных массивах.

Было решено сделать реализацию программы через матрицу (двумерный массив). После образования матрицы в ней в цикле для каждой строки проверялись числа на простоту/сложность и выводился соответствующий результатдля всей строки.

\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с %пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.

Было решено выделить одну функцию для взаимодействия с пользователем, в файле \verb-matrix.c-:
\begin{enumerate}
\item[•] \verb-matrix- для взаимодействия с пользователем через консоль и запроса у него размеров матрицы (это основная функция, так как она вызывает функции бизнес-логики)
\end{enumerate}


Для бизнес логики было решено выделить две функции,находящиеся в файлах \verb-matrixmaker.c- и \verb-matrixnumbercheck.c- соответственно:
 \begin{enumerate}
\item[•] \verb-matrixmaker-. В этой функции реализовано построение матрицы и вывод итоговой строки (содержащей только простые/составные числа).
\item[•] \verb-matrixnumbercheck- В этой функции осуществляется проверка числа на признак простое/сложное
\end{enumerate}


\subsection{Описание тестового стенда и методики тестирования}
%Среда, компилятор, операционная система, др.
Использовался QtCreator с GCC компилятором
Операционная система: Windows 7


%Ручное тестирование, автоматическое, статический анализ кода, динамический.
Ручное тестирование проводилось в большом размере.
Для статического анализа был использован cppcheckgui. Ошибок и предупреждений не было.
Автоматическое тестирование с применением модульных тестов не проводилось.

\subsection{Листинги}
\lstinputlisting[]
{../sources/app/matrix.h}
\lstinputlisting[]
{../sources/app/matrix.c}
\lstinputlisting[]
{../sources/app/matrixmaker.h}
\lstinputlisting[]
{../sources/app/matrixmaker.c}
\lstinputlisting[]
{../sources/app/matrixnumbercheck.h}
\lstinputlisting[]
{../sources/app/matrixnumbercheck.c}

\chapter{Строки}

\section{Задание 1}

\subsection{Задание}

В заданном тексте найти самое длинное слово и самое длинное предложение.

\subsection{Теоретические сведения}

%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
Было использовано:
\begin{enumerate}
\item[•] несколько функций для ввода и вывода информации, прототипы которых находятся в <stdio.h>
\item[•] функции работы со строками, прототипы которых находятся в <string.h>
\end{enumerate}

%Сведения о предметной области, которые позволили реализовать алгоритм решения задачи.
Потребовалось знания синтаксиса языка С и понимание представления строк в языке си.

Программа была реализована с помощью вспомогательных строк, в которую, посредством посимвольного анализа текста, заносилось самое длинное слово и предложение соответственно.

\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с %пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.

Для решения поставленной задачи было решено выделить две функции, находящиеся в файле \verb-strings.c-:


\begin{enumerate}
\item[•] \verb-strings- в этой функции реализована логика работы приложения - разбиение текста на слова и предложения.
\item[•] \verb-read_word- - эта функция отвечает за посимвольное чтение слов из файла, открытого функцией \verb-strings-
\end{enumerate}

\subsection{Описание тестового стенда и методики тестирования}
%Среда, компилятор, операционная система, др.
Использовался QtCreator с GCC компилятором
Операционная система: Windows 7


%Ручное тестирование, автоматическое, статический анализ кода, динамический.
Ручное тестирование практически отсутстовало.
Для статического анализа был использован cppcheckgui. Ошибок и предупреждений не было.
Автоматические тестирование с применением моульнх тестов не проводилось.


\subsection{Выводы}

При написании программы возникли проблемы, вызванные незнанием синтаксиса строковых функций из <string.h> и отсутствием опыта работы со строками в целом. Однако, эти проблемы были решены в ходе работы.

\subsection{Листинги}
\lstinputlisting[]
{../sources/pricelistapp/pricelist.cpp}
\lstinputlisting[]
{../sources/pricelistapp/pricelist.h}



\chapter{Задание на классы}

\section{Прейскурант}

\subsection{Задание}

Реализовать класс ПРЕЙСКУРАНТ (таблица товаров и цен). Требуемые методы: конструктор, деструктор, вставка товара и цены, удаление товара, поиск цены товара.

\subsection{Теоретические сведения}

%Конструкции языка, библиотечные функции, инструменты использованные при разработке приложения.
Было использовано:
\begin{enumerate}
\item[•] <iostream> и пространство имен std, для взаимодействия с пользователем через консоль.
\end{enumerate}

%Сведения о предметной области, которые позволили реализовать алгоритм решения задачи.

В ходе работы был реализован класс ПРЕЙСКУРАНТ, со всеми требуемыми методами, которые были реализованы по отдельности.

\subsection{Проектирование}
%Какие функции было решено выделить, какие у этих функций контракты, как организовано взаимодействие с %пользователем (чтение/запись из консоли, из файла, из параметров командной строки), форматы файлов и др.

В классе были реализованы следующие поля:
\begin{enumerate}
\item[•]  \verb-number_of_goods- - переменная, отвечающая за количество товаров в прейскуранте
\item[•]  \verb-price- - цена товара
\item[•]  \verb-name- - переменная типа \verb-std::string-, отвечающая за наименование товара
\end{enumerate}

и методы:
\begin{enumerate}
\item[•]  \verb-setprice- - установить цену товара
\item[•]  \verb-setname- - установить наименование товара
\item[•]  \verb-getprice- - функция, возвращающая цену товара (поиск цены товара)
\item[•]  \verb-getname- - функция, возвращающая наименование товара (поиск наименования товара)
\item[•]  \verb-productdeleat- - функция, удаляющая товар из прайс-листа (в данном случае она очищает значение цены и наименования товара)
\end{enumerate}


\subsection{Описание тестового стенда и методики тестирования}
%Среда, компилятор, операционная система, др.
Использовался QtCreator с GCC компилятором
Операционная система: Windows 7


%Ручное тестирование, автоматическое, статический анализ кода, динамический.
Ручное тестирование присутствовало в небольшом объеме.
Для статического анализа был использован cppcheckgui. Все предупреждения были либо исправлены в процессе работы, либо оказались несущественными.
Автоматическое тестирование с применением модульных тестов не проводилось.

\subsection{Выводы}

В ходе выполнения возникло много проблем в связи с пониманием класса и синтаксисом языка с++, однако в ходе работы все проблем были решены и исполнитель приобрел ценный опыт работы с классами.
\subsection{Листинги}
\lstinputlisting[]
{../sources/pricelistapp/pricelist.cpp}

\end{document} 